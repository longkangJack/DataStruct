一、指针的概念
要知道指针的概念，要先了解变量在内存中如何存储的。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。
1.1、变量和地址
先写一段简单的代码：
void main(){
	int x = 10, int y = 20;
}
这段代码非常简单，就是两个变量的声明，分别赋值了 10、20。我们把内存当做一个酒店，而每个房间就是一块内存。
那么“int x = 10; ”和“int y = 20; ”的实际含义如下：

去酒店订了两个房间，门牌号暂时用 px、py 表示
让 10 住进 px，
让 y 住进 py
其中门牌号就是 px、py 就是变量的地址
x 和 y 在这里可以理解为具体的房间，
房间 x 的门牌号（地址）是 px，房间 y 的门牌号（地址）是 py。而 10 和 20，通过 px、py 两个门牌，找到房间，住进 x、y
在我们定义一个变量的时候，要确定它的类型。int x、char ch、float、、、在定义指针变量时也是一样的，必须确定指
针类型。
int 变量的指针需要用 int 类型的指针存储，float 变量的指针需要用 float 类型的指针存储。就像你只能用酒店 A 的房卡存储酒店 A 中房间号的信息一样。
二、变量的指针与指针变量
变量的指针就是变量的存储地址，指针变量就是存储指针的变量。
2.1、指针变量的定义及使用
（1）指针变量的定义
指针变量的定义形式如：数据类型 *指针名; 例如：
//分别定义了 int、float、char 类型的指针变量
int *x;
float *f;
char *ch;
2）指针变量的使用
取地址运算符&：单目运算符&是用来取操作对象的地址。例：&i 为取变量 i 的地址。
对于常量表达式、寄存器变量不能取地址（因为它们存储在存储器中，没有地址）。
指针运算符*（间接寻址符）：与&为逆运算，作用是通过操作对象的地址，获取存储的内容。
例：x = &i，x 为 i 的地址，*x 则为通过 i 的地址，获取 i 的内容。
//声明了一个普通变量 a
int a;
//声明一个指针变量，指向变量 a 的地址
int *pa;
//通过取地址符&，获取 a 的地址，赋值给指针变量
pa = &a;
//通过间接寻址符，获取指针指向的内容
printf("%d", *pa);
（3）“&”和“*”的结合方向
“&”和“*”都是右结合的。假设有变量 x = 10，则*&x 的含义是，
先获取变量 x 的地址，再获取地址中的内容。因为“&”和“*”互为逆运算，所以 x = *&x。
void main(){
	//声明两个普通变量
	int x, y;
	//声明两个指针变量
	int *px, *py;
	//声明一个临时变量，用于交换
	int t;
	//输入两个值，赋值给 x、y
	scanf("%d", &x);
	scanf("%d", &y);
	//给指针变量 px、py 赋初值（关联变量 x、y）
	px = &x;
	py = &y;
	//利用指针来对比 x、y 的值，如果 x 的值比 y 的值小，就交换
	if (*px < *py){
		//交换步骤，其中*px == x、*py == y
		t = *px;
		*px = *py;
		*py = t;
	}
	printf("x =  %d, y = %d", *px, *py);
}
输入：23 45
输出结果为：x = 45, y = 23
2.2、指针变量的初始化
指针变量与其它变量一样，在定义时可以赋值，即初始化。
也可以赋值“NULL”或“0”，如果赋值“0”，此时的“0”含义并不是数字“0”，而是 NULL 的字符码值。
//利用取地址获取 x 的地址，在指针变量 px 定义时，赋值给 px
int x;
int *px = &x;
//定义指针变量，分别赋值“NULL”和“0”
int *p1 = NULL, *p2 = 0;
2.3、指针运算
（1）赋值运算
指针变量可以互相赋值，也可以赋值某个变量的地址，或者赋值一个具体的地址
int *px, *py, *pz, x = 10;
//赋予某个变量的地址
px = &x;
//相互赋值
py = px;
//赋值具体的地址
pz = 4000;
（2）指针与整数的加减运算
1.指针变量的自增自减运算。指针加 1 或减 1 运算，表示指针向前或向后移动一个单元（不同类型的指针，单元长度不同）。这个在数组中非常常用。
2.指针变量加上或减去一个整形数。和第一条类似，具体加几就是向前移动几个单元，减几就是向后移动几个单元。
//定义三个变量，假设它们地址为连续的，分别为 4000、4004、4008
int x, y, z;

//定义一个指针，指向 x
int *px = &x;

//利用指针变量 px 加减整数，分别输出 x、y、z
printf("x = %d", *px);		//因为 px 指向 x，所以*px = x

//px + 1，表示，向前移动一个单元（从 4000 到 4004）
//这里要先(px + 1)，再*(px + 1)获取内容，因为单目运算符“*”优先级高于双目运算符“+”
printf("y = %d", *(px + 1));
printf("z = %d", *(px + 2));
(3）关系运算
	假设有指针变量 px、py。
	1.px > py 表示 px 指向的存储地址是否大于 py 指向的地址
	2.px == py 表示 px 和 py 是否指向同一个存储单元
	3.px == 0 和 px != 0 表示 px 是否为空指针
	//定义一个数组，数组中相邻元素地址间隔一个单元
	int num[2] = { 1, 3 };

//将数组中第一个元素地址和第二个元素的地址赋值给 px、py
int *px = num[0], *py = num[1];
int *pz = num[0];
int *pn;

//则 py > px
if (py > px){
	printf("py 指向的存储地址大于 px 所指向的存储地址");
}

//pz 和 px 都指向 num[0]
if (pz == px){
	printf("px 和 pz 指向同一个地址");
}

//pn 没有初始化
if (pn == NULL || pn == 0){
	printf("pn 是一个空指针");
}
三、指针与数组
之前我们可以通过下标访问数组元素，学习了指针之后，我们可以通过指针访问数组的元素。
在数组中，数组名即为该数组的首地址，结合上面指针和整数的加减，我们就可以实现指针访问数组元素。
3.1、指向数组的指针
如以下语句：
int nums[10], *p;
上面语句定义了一个数组 nums，在定义时分配了 10 个连续的int 内存空间。
而一个数组的首地址即为数组名nums，或者第一个元素的首地址也是数组的首地址。那么有两种方式让指针变量 p 指向数组 nums：
//数组名即为数组的首地址
p = nums;
//数组第一个元素的地址也是数组的首地址
p = &nums[0];

//定义一个整形数组，并初始化
int nums[5] = { 4, 5, 3, 2, 7 };

//定义一个指针变量 p，将数组 nums 的首地址赋值给 p，也可以用&p = nums[0]赋值
int *p = nums, i;			//i 作为循环变量

//p 指向数组第一个元素（数组首地址），我们可以直接用间接寻址符，获取第一个元素的内容
printf("nums[0] = %d\n", *p);			//输出结果为 nums[0] = 4

//我们可以通过“p + 整数”来移动指针，要先移动地址，所以 p + 1 要扩起来
printf("nums[1] = %d\n", *(p + 1));		//输出结果为 nums[1] = 5

//由上面推导出*(p + i) = nums[i]，所以我们可以通过 for 循环变量元素
for (i = 0; i < 5; i++){
	printf("nums[%d] = %d", i, *(p + i));
}
注：数组名不等价于指针变量，指针变量可以进行 p++和&操作，而这些操作对于数组名是非法的。
数组名在编译时是确定的，在程序运行期间算一个常量。
3.2、字符指针与字符数组
在 C 语言中本身没有提供字符串数据类型，但是可以通过字符数组和字符指针的方式存储字符串。
1.字符串数组
char word[] = "zack";
printf("%s", word);
2.字符指针方式
指针方式操作字符串和数组操作字符串类似，可以把定义的指针看做是字符数组的数组名。在内存中存储大致如下，
比如 字符串abc 在内存中存储为 a  b  c   \0
//除了定义一个字符数组外，还可以直接定义一个字符指针存储字符串
char *sentence = "Do not go gentle into that good night!";

//此时可以做字符串的操作
//输出
printf("%s", sentence);

//通过下标取字符
printf("%c", sentence[0]);

//获取字符串长度，其中 strlen 是 string.h 库中的方法
printf("%d", strlen(sentence));
注：字符指针方式区别于字符数组方式，字符数组不能通过数组名自增操作，但是字符指针是指针，可以自增操作。
自增自减少会实现什么效果大家可以自己尝试运行一下
利用字符指针将字符数组 sentence 中的内容复制到字符数组 word 中：
//定义字符数组 sentence 和 word，给 sentence 赋初值
char sentence[] = "Do not go gentle into that good night!", word[100];

//定义字符指针，指向 word
char *ch = word;
int i;

//循环赋值
for (i = 0; sentence[i] != '\0'; i++){
	*(ch + i) = sentence[i];
}

//在当 i 等于 sentence 的长度（sentence 的长度不包含'\0'）时，
//i 继续自增，此时判断 sentence[0] != '\0'不符合，跳出循环，则 i 比 sentence 长度大 1
*(ch + i) = '\0';

//输出字符串，因为 ch 指向 word，所以输出结果是一样的
printf("ch = %s, word = %s", ch, word);
注：指针变量必须初始化一个有效值才能使用
3.3、多级指针及指针数组
（1）多级指针
指针变量作为一个变量也有自己的存储地址，而指向指针变量的存储地址就被称为指针的指针，
即二级指针。依次叠加，就形成了多级指针。我们先看看二级指针，它们关系如下：
数据类型 **二级指针名;
和指针变量的定义类似，由于*是右结合的，所以*pp 相当于*(*p)。
在本次定义中，二级指针的变量名为 pp，而不是**p。多级指针的定义就是定义时使用多个“*”号。
下面用一个小程序给大家举例：
//定义普通变量和指针变量
int *pi, i = 10;
//定义二级指针变量
int **ppi;

//给指针变量赋初值
pi = &i;

//给二级指针变量赋初值
ppi = &pi;

//我们可以直接用二级指针做普通指针的操作
//获取 i 的内容
printf("i = %d", **ppi);
//获取 i 的地址
printf("i 的地址为%d", *ppi);
（2）指针数组
指针变量和普通变量一样，也能组成数组，指针数组的具体定义如下：
数据类型 *数组名[指针数组长度];
//定义一个数组
int nums[5] = { 2, 3, 4, 5, 2 }, i;

//定义一个指针数组
int *p[5];

//定义一个二级指针
int **pp;

//循环给指针数组赋值
for (i = 0; i < 5; i++){
	p[i] = &nums[i];
}

//将指针数组的首地址赋值给 pp，数组 p 的数组名作为 p 的首地址，也作为 p 中第一个元素的地址。
//数组存放的内容为普通变量，则数组名为变量的指针；数组存放的内容为指针，则数组名为指针的指针。
pp = p;

//利用二级指针 pp 输出数组元素
for (i = 0; i < 5; i++){
	//pp == &p[0] == &&nums[0]，nums[0] == *p[0] == **pp
	printf("%d", **pp);

	//指针变量+整数的操作，即移动指针至下一个单元
	pp++;
}
1）多维数组的地址
先用一个简单的数组来举例：
int nums[2][2] = {
	{ 1, 2 },
	{ 2, 3 }
};
我们知道数组名即为数组首地址，上面的二维数组有两个维度。首先我们把按照上面 1 来理解，那么 nums 就是一个数组，则nums 就作为这个数组的首地址。
第二个维度还是取 nums[0]，我们把 nums[0]作为一个名称，其中有两个元素。我们可以尝试以下语句：
//假设已初始化，二维数组数据类型设为 x，一维数组数据类型设为 y
int nums[2][2][2];

//此数组首地址为该数组名称
printf("此数组首地址为%d", nums);

//此数组可以看做存储了两个 x 类型元素的一维数组，则 nums[0] = x1 的地址为
printf("第二个维度的首地址为%d", nums[0]);

//而 x1 可以看做存储了两个 y 类型元素的一维数组，则 y1 = x1[0] = nums[0][0]
printf("第三个维度的首地址为%d", nums[0][0]);
实际存储内容的为最内层维度，且为连续的。对于 a 来说，其个跨度为 4 个单元；对 a[0]来说，
其跨度为 2 个单元；对 a[0][0]来说，跨度为一个单元。有上面还可以得出：
a == a[0] == a[0][0] == &a[0][0][0];
四、指针与函数
前面学习函数学到，函数参数可以为 int、char、float 等，但是在操作时，
这些参数只作为形参，所有操作都只在函数体内有效（除对指针的操作外），那么今天来学习一下指针作为函数参数。

4.
1、函数参数为指针
我们直接做一个练习，定义一个函数，用来交换两个变量的内容。
void swap(int *x, int *y);
void main(){
	int x = 20, y = 10;
	swap(&x, &y);
	printf("x = %d, y = %d", x, y);
}
void swap(int *x, int *y){
	int t;
	t = *x;
	*x = *y;
	*y = t;
}
代码非常简单，我也就不细讲了。这里传入的参数为指针，所以调用 swap 方法后 x，y 的内容发生了交换。
如果直接传入 x，y，那么交换只在 swap 中有效，在 main 中并没有交换。
(因为传入的不是地址，形参只是实参的一份临时拷贝，内容拷贝过去了但是空间没有变，根没有变，所以内容不会发生变化)
4.3、指向函数的指针
C 语言中，函数不能嵌套定义，也不能将函数作为参数传递。但是函数有个特性，即函数名为该函数的入口地址。
我们可以定义一个指针指向该地址，将指针作为参数传递。
函数指针定义如下：
数据类型(*函数指针名)();
函数指针在进行“*”操作时，可以理解为执行该函数。函数指针不同与数据指针，不能进行 + 整数操作。
下面举个例子，来使用函数指针：
#include <string.h>
/**
*	定义一个方法，传入两个字符串和一个函数指针 p，用 p 对两个字符串进行操作
*/
void check(char *x, char *y, int(*p)());
void main(){
	//string.h 库中的函数，使用之前需要声明该函数。字符串比较函数
	int strcmp();
	char x[] = "Zack";
	char y[] = "Rudy";

	//定义一个函数指针
	int(*p)() = strcmp;
}
void check(char *x, char *y, int(*p)()){
	if (!(*p)(x, y)){
		printf("相等");
	}
	else{
		printf("不相等");
	}
}
利用函数指针调用方法具体操作如下：
(*p)(x, y);




